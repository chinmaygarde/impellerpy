var __index = {"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"ImpellerPy","text":"<p>Python bindings to standalone Impeller. Flutters rendering engine.</p>"},{"location":"reference.html","title":"API Reference","text":""},{"location":"reference.html#impellerpy.__all__","title":"<code>__all__ = ['Rect', 'Point', 'Size', 'ISize', 'Range', 'Matrix', 'ColorMatrix', 'RoundingRadii', 'Color', 'TextureDescriptor', 'ColorFilter', 'ColorSource', 'ImageFilter', 'MaskFilter', 'Paint', 'DisplayList', 'Path', 'LineMetrics', 'GlyphInfo', 'Paragraph', 'Texture', 'DisplayListBuilder', 'PathBuilder', 'Surface', 'Context', 'Window', 'TypographyContext', 'ParagraphStyle', 'ParagraphBuilder', 'FillType', 'ClipOperation', 'BlendMode', 'DrawStyle', 'StrokeCap', 'StrokeJoin', 'PixelFormat', 'TextureSampling', 'TileMode', 'BlurStyle', 'ColorSpace', 'FontWeight', 'FontStyle', 'TextAlignment', 'TextDirection']</code>  <code>module-attribute</code>","text":""},{"location":"reference.html#impellerpy.BlendMode","title":"<code>BlendMode</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Determines how source and destination colors are combined during drawing.</p> <p>These blend modes follow the standard Porter-Duff compositing operations and additional blend modes from PDF and SVG specifications.</p>"},{"location":"reference.html#impellerpy.BlendMode.CLEAR","title":"<code>CLEAR = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Clear destination (0)</p>"},{"location":"reference.html#impellerpy.BlendMode.COLOR","title":"<code>COLOR = 27</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Hue and saturation from source, luminosity from destination</p>"},{"location":"reference.html#impellerpy.BlendMode.COLOR_BURN","title":"<code>COLOR_BURN = 19</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Darkens destination based on source</p>"},{"location":"reference.html#impellerpy.BlendMode.COLOR_DODGE","title":"<code>COLOR_DODGE = 18</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Brightens destination based on source</p>"},{"location":"reference.html#impellerpy.BlendMode.DARKEN","title":"<code>DARKEN = 16</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Darker of source and destination</p>"},{"location":"reference.html#impellerpy.BlendMode.DESTINATION","title":"<code>DESTINATION = 2</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Preserve destination (D)</p>"},{"location":"reference.html#impellerpy.BlendMode.DESTINATION_ATOP","title":"<code>DESTINATION_ATOP = 10</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Destination atop source (SaD + (1-Da)S)</p>"},{"location":"reference.html#impellerpy.BlendMode.DESTINATION_IN","title":"<code>DESTINATION_IN = 6</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Destination where source is non-zero (Sa*D)</p>"},{"location":"reference.html#impellerpy.BlendMode.DESTINATION_OUT","title":"<code>DESTINATION_OUT = 8</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Destination where source is zero ((1-Sa)*D)</p>"},{"location":"reference.html#impellerpy.BlendMode.DESTINATION_OVER","title":"<code>DESTINATION_OVER = 4</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Destination over source (D + (1-Da)*S)</p>"},{"location":"reference.html#impellerpy.BlendMode.DIFFERENCE","title":"<code>DIFFERENCE = 22</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Absolute difference between source and destination</p>"},{"location":"reference.html#impellerpy.BlendMode.EXCLUSION","title":"<code>EXCLUSION = 23</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Similar to DIFFERENCE but with lower contrast</p>"},{"location":"reference.html#impellerpy.BlendMode.HARD_LIGHT","title":"<code>HARD_LIGHT = 20</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Hard light blend mode</p>"},{"location":"reference.html#impellerpy.BlendMode.HUE","title":"<code>HUE = 25</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Hue from source, saturation and luminosity from destination</p>"},{"location":"reference.html#impellerpy.BlendMode.LIGHTEN","title":"<code>LIGHTEN = 17</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Lighter of source and destination</p>"},{"location":"reference.html#impellerpy.BlendMode.LUMINOSITY","title":"<code>LUMINOSITY = 28</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Luminosity from source, hue and saturation from destination</p>"},{"location":"reference.html#impellerpy.BlendMode.MODULATE","title":"<code>MODULATE = 13</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Product of source and destination (S*D)</p>"},{"location":"reference.html#impellerpy.BlendMode.MULTIPLY","title":"<code>MULTIPLY = 24</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Multiply source and destination</p>"},{"location":"reference.html#impellerpy.BlendMode.OVERLAY","title":"<code>OVERLAY = 15</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Overlay blend mode</p>"},{"location":"reference.html#impellerpy.BlendMode.PLUS","title":"<code>PLUS = 12</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Sum of source and destination (S + D)</p>"},{"location":"reference.html#impellerpy.BlendMode.SATURATION","title":"<code>SATURATION = 26</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Saturation from source, hue and luminosity from destination</p>"},{"location":"reference.html#impellerpy.BlendMode.SCREEN","title":"<code>SCREEN = 14</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Screen blend mode</p>"},{"location":"reference.html#impellerpy.BlendMode.SOFT_LIGHT","title":"<code>SOFT_LIGHT = 21</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Soft light blend mode</p>"},{"location":"reference.html#impellerpy.BlendMode.SOURCE","title":"<code>SOURCE = 1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Copy source (S)</p>"},{"location":"reference.html#impellerpy.BlendMode.SOURCE_ATOP","title":"<code>SOURCE_ATOP = 9</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Source atop destination (DaS + (1-Sa)D)</p>"},{"location":"reference.html#impellerpy.BlendMode.SOURCE_IN","title":"<code>SOURCE_IN = 5</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Source where destination is non-zero (Da*S)</p>"},{"location":"reference.html#impellerpy.BlendMode.SOURCE_OUT","title":"<code>SOURCE_OUT = 7</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Source where destination is zero ((1-Da)*S)</p>"},{"location":"reference.html#impellerpy.BlendMode.SOURCE_OVER","title":"<code>SOURCE_OVER = 3</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Source over destination (S + (1-Sa)*D)</p>"},{"location":"reference.html#impellerpy.BlendMode.XOR","title":"<code>XOR = 11</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Exclusive OR ((1-Sa)D + (1-Da)S)</p>"},{"location":"reference.html#impellerpy.BlurStyle","title":"<code>BlurStyle</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Determines how blur mask filters are applied.</p>"},{"location":"reference.html#impellerpy.BlurStyle.INNER","title":"<code>INNER = 3</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Blur only inside the shape.</p>"},{"location":"reference.html#impellerpy.BlurStyle.NORMAL","title":"<code>NORMAL = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Blur in all directions.</p>"},{"location":"reference.html#impellerpy.BlurStyle.OUTER","title":"<code>OUTER = 2</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Blur only outside the shape.</p>"},{"location":"reference.html#impellerpy.BlurStyle.SOLID","title":"<code>SOLID = 1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Blur and preserve the original shape.</p>"},{"location":"reference.html#impellerpy.ClipOperation","title":"<code>ClipOperation</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Determines how clip regions are combined.</p>"},{"location":"reference.html#impellerpy.ClipOperation.DIFFERENCE","title":"<code>DIFFERENCE = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Subtracts the new clip region from the current clip.</p>"},{"location":"reference.html#impellerpy.ClipOperation.INTERSECT","title":"<code>INTERSECT = 1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Intersects the new clip region with the current clip.</p>"},{"location":"reference.html#impellerpy.Color","title":"<code>Color</code>","text":"<p>               Bases: <code>Color_</code></p>"},{"location":"reference.html#impellerpy.Color.alpha","title":"<code>alpha = a</code>  <code>instance-attribute</code>","text":""},{"location":"reference.html#impellerpy.Color.blue","title":"<code>blue = b</code>  <code>instance-attribute</code>","text":""},{"location":"reference.html#impellerpy.Color.green","title":"<code>green = g</code>  <code>instance-attribute</code>","text":""},{"location":"reference.html#impellerpy.Color.red","title":"<code>red = r</code>  <code>instance-attribute</code>","text":""},{"location":"reference.html#impellerpy.Color.__init__","title":"<code>__init__(r=0.0, g=0.0, b=0.0, a=0.0)</code>","text":""},{"location":"reference.html#impellerpy.ColorFilter","title":"<code>ColorFilter</code>","text":"<p>               Bases: <code>ColorFilter_</code></p>"},{"location":"reference.html#impellerpy.ColorFilter_","title":"<code>ColorFilter_</code>","text":"<p>A filter that transforms colors before they are drawn.</p> <p>Color filters are functions that take two colors and mix them to produce a single color. This color is then merged with the destination during blending.</p>"},{"location":"reference.html#impellerpy.ColorFilter_.blend","title":"<code>blend(color, blend_mode)</code>  <code>staticmethod</code>","text":"<p>Create a color filter that performs blending of pixel values independently.</p> <p>Parameters:</p> Name Type Description Default <code>color</code> <code>Color_</code> <p>The color to blend with.</p> required <code>blend_mode</code> <code>BlendMode</code> <p>The blend mode to use for combining colors.</p> required <p>Returns:</p> Type Description <code>ColorFilter_</code> <p>A new color filter that performs the specified blending.</p>"},{"location":"reference.html#impellerpy.ColorFilter_.matrix","title":"<code>matrix(matrix)</code>  <code>staticmethod</code>","text":"<p>Create a color filter that transforms pixel color values independently.</p> <p>Parameters:</p> Name Type Description Default <code>matrix</code> <code>ColorMatrix_</code> <p>The color matrix to use for transforming colors.</p> required <p>Returns:</p> Type Description <code>ColorFilter_</code> <p>A new color filter that applies the specified color matrix transformation.</p>"},{"location":"reference.html#impellerpy.ColorMatrix","title":"<code>ColorMatrix</code>","text":"<p>               Bases: <code>ColorMatrix_</code></p>"},{"location":"reference.html#impellerpy.ColorMatrix_","title":"<code>ColorMatrix_</code>","text":"<p>A 4x5 color transformation matrix used for transforming color values.</p> <p>The matrix is used to transform RGBA colors using the formula: <pre><code>| R' |   | m[0]  m[1]  m[2]  m[3]  m[4]  |   | R |\n| G' |   | m[5]  m[6]  m[7]  m[8]  m[9]  |   | G |\n| B' | = | m[10] m[11] m[12] m[13] m[14] | * | B |\n| A' |   | m[15] m[16] m[17] m[18] m[19] |   | A |\n| 1  |   | 0     0     0     0     1     |   | 1 |\n</code></pre></p>"},{"location":"reference.html#impellerpy.ColorMatrix_.__getitem__","title":"<code>__getitem__(key)</code>","text":"<p>Get the value at the specified index.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>int</code> <p>The index (0-19) to retrieve.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The float value at the specified index.</p>"},{"location":"reference.html#impellerpy.ColorMatrix_.__init__","title":"<code>__init__(values)</code>","text":"<p>Initialize a color matrix with the provided values.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>List[float]</code> <p>A list of 20 float values representing the 4x5 color matrix.</p> required"},{"location":"reference.html#impellerpy.ColorMatrix_.__setitem__","title":"<code>__setitem__(key, value)</code>","text":"<p>Set the value at the specified index.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>int</code> <p>The index (0-19) to modify.</p> required <code>value</code> <code>float</code> <p>The new float value to set.</p> required"},{"location":"reference.html#impellerpy.ColorMatrix_.to_list","title":"<code>to_list()</code>","text":"<p>Convert the color matrix to a list of float values.</p> <p>Returns:</p> Type Description <code>List[float]</code> <p>A list of 20 float values representing the color matrix.</p>"},{"location":"reference.html#impellerpy.ColorSource","title":"<code>ColorSource</code>","text":"<p>               Bases: <code>ColorSource_</code></p>"},{"location":"reference.html#impellerpy.ColorSource_","title":"<code>ColorSource_</code>","text":"<p>A source of colors for drawing operations.</p> <p>Color sources are functions that generate colors for each texture element covered by a draw call. The colors can be generated using a mathematical function (to produce gradients) or sampled from a texture.</p>"},{"location":"reference.html#impellerpy.ColorSource_.conical_gradient","title":"<code>conical_gradient(start_center, start_radius, end_center, end_radius, stops, colors, tile_mode, transformation=None)</code>  <code>staticmethod</code>","text":"<p>Create a color source that forms a conical gradient.</p> <p>Parameters:</p> Name Type Description Default <code>start_center</code> <code>Point_</code> <p>The center point of the starting circle.</p> required <code>start_radius</code> <code>float</code> <p>The radius of the starting circle.</p> required <code>end_center</code> <code>Point_</code> <p>The center point of the ending circle.</p> required <code>end_radius</code> <code>float</code> <p>The radius of the ending circle.</p> required <code>stops</code> <code>List[float]</code> <p>The positions of color stops (0.0 to 1.0).</p> required <code>colors</code> <code>List[Color_]</code> <p>The colors at each stop position.</p> required <code>tile_mode</code> <code>TileMode</code> <p>How to handle coordinates outside the gradient.</p> required <code>transformation</code> <code>Optional[Matrix_]</code> <p>Optional transformation matrix to apply.</p> <code>None</code> <p>Returns:</p> Type Description <code>ColorSource_</code> <p>A new color source that generates a conical gradient.</p>"},{"location":"reference.html#impellerpy.ColorSource_.image","title":"<code>image(texture, horizontal_tile_mode, vertical_tile_mode, sampling, transformation=None)</code>  <code>staticmethod</code>","text":"<p>Create a color source that samples from an image.</p> <p>Parameters:</p> Name Type Description Default <code>texture</code> <code>Texture_</code> <p>The texture to sample from.</p> required <code>horizontal_tile_mode</code> <code>TileMode</code> <p>How to handle coordinates outside the texture horizontally.</p> required <code>vertical_tile_mode</code> <code>TileMode</code> <p>How to handle coordinates outside the texture vertically.</p> required <code>sampling</code> <code>TextureSampling</code> <p>The sampling method to use when reading the texture.</p> required <code>transformation</code> <code>Optional[Matrix_]</code> <p>Optional transformation matrix to apply.</p> <code>None</code> <p>Returns:</p> Type Description <code>ColorSource_</code> <p>A new color source that samples from the specified texture.</p>"},{"location":"reference.html#impellerpy.ColorSource_.linear_gradient","title":"<code>linear_gradient(start_point, end_point, colors, stops, tile_mode, transformation=None)</code>  <code>staticmethod</code>","text":"<p>Create a color source that forms a linear gradient.</p> <p>Parameters:</p> Name Type Description Default <code>start_point</code> <code>Point_</code> <p>The starting point of the gradient.</p> required <code>end_point</code> <code>Point_</code> <p>The ending point of the gradient.</p> required <code>colors</code> <code>List[Color_]</code> <p>The colors at each stop position.</p> required <code>stops</code> <code>List[float]</code> <p>The positions of color stops (0.0 to 1.0).</p> required <code>tile_mode</code> <code>TileMode</code> <p>How to handle coordinates outside the gradient.</p> required <code>transformation</code> <code>Optional[Matrix_]</code> <p>Optional transformation matrix to apply.</p> <code>None</code> <p>Returns:</p> Type Description <code>ColorSource_</code> <p>A new color source that generates a linear gradient.</p>"},{"location":"reference.html#impellerpy.ColorSource_.radial_gradient","title":"<code>radial_gradient(center, radius, colors, stops, tile_mode, transformation=None)</code>  <code>staticmethod</code>","text":"<p>Create a color source that forms a radial gradient.</p> <p>Parameters:</p> Name Type Description Default <code>center</code> <code>Point_</code> <p>The center point of the gradient.</p> required <code>radius</code> <code>float</code> <p>The radius of the gradient.</p> required <code>colors</code> <code>List[Color_]</code> <p>The colors at each stop position.</p> required <code>stops</code> <code>List[float]</code> <p>The positions of color stops (0.0 to 1.0).</p> required <code>tile_mode</code> <code>TileMode</code> <p>How to handle coordinates outside the gradient.</p> required <code>transformation</code> <code>Optional[Matrix_]</code> <p>Optional transformation matrix to apply.</p> <code>None</code> <p>Returns:</p> Type Description <code>ColorSource_</code> <p>A new color source that generates a radial gradient.</p>"},{"location":"reference.html#impellerpy.ColorSource_.sweep_gradient","title":"<code>sweep_gradient(center, start, end, colors, stops, tile_mode, transformation=None)</code>  <code>staticmethod</code>","text":"<p>Create a color source that forms a sweep gradient.</p> <p>Parameters:</p> Name Type Description Default <code>center</code> <code>Point_</code> <p>The center point of the gradient.</p> required <code>start</code> <code>float</code> <p>The starting angle in degrees.</p> required <code>end</code> <code>float</code> <p>The ending angle in degrees.</p> required <code>colors</code> <code>List[Color_]</code> <p>The colors at each stop position.</p> required <code>stops</code> <code>List[float]</code> <p>The positions of color stops (0.0 to 1.0).</p> required <code>tile_mode</code> <code>TileMode</code> <p>How to handle coordinates outside the gradient.</p> required <code>transformation</code> <code>Optional[Matrix_]</code> <p>Optional transformation matrix to apply.</p> <code>None</code> <p>Returns:</p> Type Description <code>ColorSource_</code> <p>A new color source that generates a sweep gradient.</p>"},{"location":"reference.html#impellerpy.ColorSpace","title":"<code>ColorSpace</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Specifies the color space for colors.</p>"},{"location":"reference.html#impellerpy.ColorSpace.DISPLAY_P3","title":"<code>DISPLAY_P3 = 2</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Display P3 color space with wider gamut than sRGB.</p>"},{"location":"reference.html#impellerpy.ColorSpace.EXTENDED_SRGB","title":"<code>EXTENDED_SRGB = 1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Extended sRGB color space with values outside [0,1].</p>"},{"location":"reference.html#impellerpy.ColorSpace.SRGB","title":"<code>SRGB = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Standard RGB color space.</p>"},{"location":"reference.html#impellerpy.Color_","title":"<code>Color_</code>","text":"<p>Represents a color with red, green, blue, and alpha components.</p> <p>Attributes:</p> Name Type Description <code>red</code> <code>float</code> <p>The red component (0.0 to 1.0).</p> <code>green</code> <code>float</code> <p>The green component (0.0 to 1.0).</p> <code>blue</code> <code>float</code> <p>The blue component (0.0 to 1.0).</p> <code>alpha</code> <code>float</code> <p>The alpha component (0.0 to 1.0).</p> <code>color_space</code> <code>ColorSpace</code> <p>The color space of the color.</p>"},{"location":"reference.html#impellerpy.Color_.alpha","title":"<code>alpha</code>  <code>instance-attribute</code>","text":""},{"location":"reference.html#impellerpy.Color_.blue","title":"<code>blue</code>  <code>instance-attribute</code>","text":""},{"location":"reference.html#impellerpy.Color_.color_space","title":"<code>color_space</code>  <code>instance-attribute</code>","text":""},{"location":"reference.html#impellerpy.Color_.green","title":"<code>green</code>  <code>instance-attribute</code>","text":""},{"location":"reference.html#impellerpy.Color_.red","title":"<code>red</code>  <code>instance-attribute</code>","text":""},{"location":"reference.html#impellerpy.Color_.__init__","title":"<code>__init__()</code>","text":"<p>Initialize a color with default values (0,0,0,0) in sRGB color space.</p>"},{"location":"reference.html#impellerpy.Context","title":"<code>Context</code>","text":"<p>               Bases: <code>Context_</code></p>"},{"location":"reference.html#impellerpy.Context_","title":"<code>Context_</code>","text":"<p>An Impeller graphics context.</p> <p>Contexts are thread-safe objects that are expensive to create. Most applications will only ever create a single context during their lifetimes. Once setup, Impeller is ready to render frames as performantly as possible.</p> <p>During setup, contexts create the underlying graphics pipelines, allocators, worker threads, etc.</p> <p>The general guidance is to create as few contexts as possible (typically just one) and share them as much as possible.</p>"},{"location":"reference.html#impellerpy.Context_.__init__","title":"<code>__init__()</code>","text":"<p>Initialize a new Metal context using the system default Metal device.</p>"},{"location":"reference.html#impellerpy.DisplayList","title":"<code>DisplayList</code>","text":"<p>               Bases: <code>DisplayList_</code></p>"},{"location":"reference.html#impellerpy.DisplayListBuilder","title":"<code>DisplayListBuilder</code>","text":"<p>               Bases: <code>DisplayListBuilder_</code></p>"},{"location":"reference.html#impellerpy.DisplayListBuilder_","title":"<code>DisplayListBuilder_</code>","text":"<p>Allows for the incremental creation of display lists.</p> <p>Display list builders are context-agnostic and can be used to create display lists that can be drawn on any surface.</p>"},{"location":"reference.html#impellerpy.DisplayListBuilder_.__init__","title":"<code>__init__()</code>","text":"<p>Initialize a new display list builder.</p>"},{"location":"reference.html#impellerpy.DisplayListBuilder_.build","title":"<code>build()</code>","text":"<p>Create a new display list using the rendering intent already encoded in the builder.</p> <p>The builder is reset after this call.</p> <p>Returns:</p> Type Description <code>DisplayList_</code> <p>A new display list.</p>"},{"location":"reference.html#impellerpy.DisplayListBuilder_.clip_oval","title":"<code>clip_oval(rect, op)</code>","text":"<p>Reduce the clip region to the intersection with the given oval.</p> <p>Parameters:</p> Name Type Description Default <code>rect</code> <code>Rect_</code> <p>The rectangle defining the oval bounds.</p> required <code>op</code> <code>ClipOperation</code> <p>The clip operation to perform.</p> required <p>Returns:</p> Type Description <code>DisplayListBuilder_</code> <p>Self for method chaining.</p>"},{"location":"reference.html#impellerpy.DisplayListBuilder_.clip_path","title":"<code>clip_path(path, op)</code>","text":"<p>Reduce the clip region to the intersection with the given path.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path_</code> <p>The path to clip with.</p> required <code>op</code> <code>ClipOperation</code> <p>The clip operation to perform.</p> required <p>Returns:</p> Type Description <code>DisplayListBuilder_</code> <p>Self for method chaining.</p>"},{"location":"reference.html#impellerpy.DisplayListBuilder_.clip_rect","title":"<code>clip_rect(rect, op)</code>","text":"<p>Reduce the clip region to the intersection with the given rectangle.</p> <p>Parameters:</p> Name Type Description Default <code>rect</code> <code>Rect_</code> <p>The rectangle to clip with.</p> required <code>op</code> <code>ClipOperation</code> <p>The clip operation to perform.</p> required <p>Returns:</p> Type Description <code>DisplayListBuilder_</code> <p>Self for method chaining.</p>"},{"location":"reference.html#impellerpy.DisplayListBuilder_.clip_rounded_rect","title":"<code>clip_rounded_rect(rect, radii, op)</code>","text":"<p>Reduce the clip region to the intersection with the given rounded rectangle.</p> <p>Parameters:</p> Name Type Description Default <code>rect</code> <code>Rect_</code> <p>The rectangle to clip with.</p> required <code>radii</code> <code>RoundingRadii_</code> <p>The corner radii of the rectangle.</p> required <code>op</code> <code>ClipOperation</code> <p>The clip operation to perform.</p> required <p>Returns:</p> Type Description <code>DisplayListBuilder_</code> <p>Self for method chaining.</p>"},{"location":"reference.html#impellerpy.DisplayListBuilder_.draw_dashed_line","title":"<code>draw_dashed_line(from_point, to_point, on_length, off_length, paint)</code>","text":"<p>Draw a dashed line segment.</p> <p>Parameters:</p> Name Type Description Default <code>from_point</code> <code>Point_</code> <p>The starting point of the line.</p> required <code>to_point</code> <code>Point_</code> <p>The ending point of the line.</p> required <code>on_length</code> <code>float</code> <p>The length of the dash.</p> required <code>off_length</code> <code>float</code> <p>The length of the gap between dashes.</p> required <code>paint</code> <code>Paint_</code> <p>The paint to use for drawing.</p> required <p>Returns:</p> Type Description <code>DisplayListBuilder_</code> <p>Self for method chaining.</p>"},{"location":"reference.html#impellerpy.DisplayListBuilder_.draw_display_list","title":"<code>draw_display_list(dl, opacity)</code>","text":"<p>Flatten the contents of another display list into this one.</p> <p>Parameters:</p> Name Type Description Default <code>dl</code> <code>DisplayList_</code> <p>The display list to draw.</p> required <code>opacity</code> <code>float</code> <p>The opacity to apply (0.0 to 1.0).</p> required <p>Returns:</p> Type Description <code>DisplayListBuilder_</code> <p>Self for method chaining.</p>"},{"location":"reference.html#impellerpy.DisplayListBuilder_.draw_line","title":"<code>draw_line(from_point, to_point, paint)</code>","text":"<p>Draw a line segment.</p> <p>Parameters:</p> Name Type Description Default <code>from_point</code> <code>Point_</code> <p>The starting point of the line.</p> required <code>to_point</code> <code>Point_</code> <p>The ending point of the line.</p> required <code>paint</code> <code>Paint_</code> <p>The paint to use for drawing.</p> required <p>Returns:</p> Type Description <code>DisplayListBuilder_</code> <p>Self for method chaining.</p>"},{"location":"reference.html#impellerpy.DisplayListBuilder_.draw_oval","title":"<code>draw_oval(oval_bounds, paint)</code>","text":"<p>Draw an oval.</p> <p>Parameters:</p> Name Type Description Default <code>oval_bounds</code> <code>Rect_</code> <p>The rectangle defining the oval bounds.</p> required <code>paint</code> <code>Paint_</code> <p>The paint to use for drawing.</p> required <p>Returns:</p> Type Description <code>DisplayListBuilder_</code> <p>Self for method chaining.</p>"},{"location":"reference.html#impellerpy.DisplayListBuilder_.draw_paint","title":"<code>draw_paint(paint)</code>","text":"<p>Fill the current clip with the specified paint.</p> <p>Parameters:</p> Name Type Description Default <code>paint</code> <code>Paint_</code> <p>The paint to use for filling.</p> required <p>Returns:</p> Type Description <code>DisplayListBuilder_</code> <p>Self for method chaining.</p>"},{"location":"reference.html#impellerpy.DisplayListBuilder_.draw_paragraph","title":"<code>draw_paragraph(paragraph, point)</code>","text":"<p>Draw a paragraph at the specified point.</p> <p>Parameters:</p> Name Type Description Default <code>paragraph</code> <code>Paragraph_</code> <p>The paragraph to draw.</p> required <code>point</code> <code>Point_</code> <p>The position to draw the paragraph at.</p> required <p>Returns:</p> Type Description <code>DisplayListBuilder_</code> <p>Self for method chaining.</p>"},{"location":"reference.html#impellerpy.DisplayListBuilder_.draw_path","title":"<code>draw_path(path, paint)</code>","text":"<p>Draw the specified shape.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path_</code> <p>The path to draw.</p> required <code>paint</code> <code>Paint_</code> <p>The paint to use for drawing.</p> required <p>Returns:</p> Type Description <code>DisplayListBuilder_</code> <p>Self for method chaining.</p>"},{"location":"reference.html#impellerpy.DisplayListBuilder_.draw_rect","title":"<code>draw_rect(rect, paint)</code>","text":"<p>Draw a rectangle.</p> <p>Parameters:</p> Name Type Description Default <code>rect</code> <code>Rect_</code> <p>The rectangle to draw.</p> required <code>paint</code> <code>Paint_</code> <p>The paint to use for drawing.</p> required <p>Returns:</p> Type Description <code>DisplayListBuilder_</code> <p>Self for method chaining.</p>"},{"location":"reference.html#impellerpy.DisplayListBuilder_.draw_rounded_rect","title":"<code>draw_rounded_rect(rect, radii, paint)</code>","text":"<p>Draw a rounded rectangle.</p> <p>Parameters:</p> Name Type Description Default <code>rect</code> <code>Rect_</code> <p>The rectangle to draw.</p> required <code>radii</code> <code>RoundingRadii_</code> <p>The corner radii of the rectangle.</p> required <code>paint</code> <code>Paint_</code> <p>The paint to use for drawing.</p> required <p>Returns:</p> Type Description <code>DisplayListBuilder_</code> <p>Self for method chaining.</p>"},{"location":"reference.html#impellerpy.DisplayListBuilder_.draw_rounded_rect_difference","title":"<code>draw_rounded_rect_difference(outer_rect, outer_radii, inner_rect, inner_radii, paint)</code>","text":"<p>Draw a shape that is the difference between two rounded rectangles.</p> <p>Parameters:</p> Name Type Description Default <code>outer_rect</code> <code>Rect_</code> <p>The outer rectangle.</p> required <code>outer_radii</code> <code>RoundingRadii_</code> <p>The corner radii of the outer rectangle.</p> required <code>inner_rect</code> <code>Rect_</code> <p>The inner rectangle.</p> required <code>inner_radii</code> <code>RoundingRadii_</code> <p>The corner radii of the inner rectangle.</p> required <code>paint</code> <code>Paint_</code> <p>The paint to use for drawing.</p> required <p>Returns:</p> Type Description <code>DisplayListBuilder_</code> <p>Self for method chaining.</p>"},{"location":"reference.html#impellerpy.DisplayListBuilder_.draw_shadow","title":"<code>draw_shadow(path, shadow_color, elevation, occuluder_is_transparent, device_pixel_ratio)</code>","text":"<p>Draw a shadow for a path given a material elevation.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path_</code> <p>The shadow path.</p> required <code>shadow_color</code> <code>Color_</code> <p>The shadow color.</p> required <code>elevation</code> <code>float</code> <p>The material elevation.</p> required <code>occuluder_is_transparent</code> <code>bool</code> <p>If the object casting the shadow is transparent.</p> required <code>device_pixel_ratio</code> <code>float</code> <p>The device pixel ratio.</p> required <p>Returns:</p> Type Description <code>DisplayListBuilder_</code> <p>Self for method chaining.</p>"},{"location":"reference.html#impellerpy.DisplayListBuilder_.draw_texture","title":"<code>draw_texture(texture, point, sampling, paint)</code>","text":"<p>Draw a texture at the specified point.</p> <p>Parameters:</p> Name Type Description Default <code>texture</code> <code>Texture_</code> <p>The texture to draw.</p> required <code>point</code> <code>Point_</code> <p>The position to draw the texture at.</p> required <code>sampling</code> <code>TextureSampling</code> <p>The sampling method to use.</p> required <code>paint</code> <code>Paint_</code> <p>The paint to use for drawing.</p> required <p>Returns:</p> Type Description <code>DisplayListBuilder_</code> <p>Self for method chaining.</p>"},{"location":"reference.html#impellerpy.DisplayListBuilder_.draw_texture_rect","title":"<code>draw_texture_rect(texture, src_rect, dst_rect, sampling, paint)</code>","text":"<p>Draw a portion of texture at the specified location.</p> <p>Parameters:</p> Name Type Description Default <code>texture</code> <code>Texture_</code> <p>The texture to draw.</p> required <code>src_rect</code> <code>Rect_</code> <p>The source rectangle within the texture.</p> required <code>dst_rect</code> <code>Rect_</code> <p>The destination rectangle to draw to.</p> required <code>sampling</code> <code>TextureSampling</code> <p>The sampling method to use.</p> required <code>paint</code> <code>Paint_</code> <p>The paint to use for drawing.</p> required <p>Returns:</p> Type Description <code>DisplayListBuilder_</code> <p>Self for method chaining.</p>"},{"location":"reference.html#impellerpy.DisplayListBuilder_.get_transform","title":"<code>get_transform()</code>","text":"<p>Get the transformation currently built up on the top of the transformation stack.</p> <p>Returns:</p> Type Description <code>Matrix_</code> <p>The current transformation matrix.</p>"},{"location":"reference.html#impellerpy.DisplayListBuilder_.push_transform","title":"<code>push_transform(xform)</code>","text":"<p>Append the provided transformation to the transformation already on the save stack.</p> <p>Parameters:</p> Name Type Description Default <code>xform</code> <code>Matrix_</code> <p>The transformation matrix to append.</p> required <p>Returns:</p> Type Description <code>DisplayListBuilder_</code> <p>Self for method chaining.</p>"},{"location":"reference.html#impellerpy.DisplayListBuilder_.reset_transform","title":"<code>reset_transform()</code>","text":"<p>Reset the transformation on top of the transformation stack to identity.</p> <p>Returns:</p> Type Description <code>DisplayListBuilder_</code> <p>Self for method chaining.</p>"},{"location":"reference.html#impellerpy.DisplayListBuilder_.restore","title":"<code>restore()</code>","text":"<p>Pop the last entry pushed onto the save stack.</p> <p>Returns:</p> Type Description <code>DisplayListBuilder_</code> <p>Self for method chaining.</p>"},{"location":"reference.html#impellerpy.DisplayListBuilder_.restore_to_count","title":"<code>restore_to_count(count)</code>","text":"<p>Restore the save stack to the specified count.</p> <p>Effectively calls restore() until the size of the save stack becomes the specified count.</p> <p>Parameters:</p> Name Type Description Default <code>count</code> <code>int</code> <p>The target save stack count.</p> required <p>Returns:</p> Type Description <code>DisplayListBuilder_</code> <p>Self for method chaining.</p>"},{"location":"reference.html#impellerpy.DisplayListBuilder_.rotate","title":"<code>rotate(angle_in_degrees)</code>","text":"<p>Apply a clockwise rotation to the transformation matrix.</p> <p>Parameters:</p> Name Type Description Default <code>angle_in_degrees</code> <code>float</code> <p>The angle in degrees.</p> required <p>Returns:</p> Type Description <code>DisplayListBuilder_</code> <p>Self for method chaining.</p>"},{"location":"reference.html#impellerpy.DisplayListBuilder_.save","title":"<code>save()</code>","text":"<p>Stash the current transformation and clip state onto a save stack.</p> <p>Returns:</p> Type Description <code>DisplayListBuilder_</code> <p>Self for method chaining.</p>"},{"location":"reference.html#impellerpy.DisplayListBuilder_.save_count","title":"<code>save_count()</code>","text":"<p>Get the current size of the save stack.</p> <p>Returns:</p> Type Description <code>int</code> <p>The save stack size.</p>"},{"location":"reference.html#impellerpy.DisplayListBuilder_.save_layer","title":"<code>save_layer(bounds, paint=None, backdrop=None)</code>","text":"<p>Save the current state and create an offscreen layer for rendering.</p> <p>On the balancing call to restore, the supplied paint's filters and blend modes will be used to composite the offscreen contents back onto the display list.</p> <p>Parameters:</p> Name Type Description Default <code>bounds</code> <code>Rect_</code> <p>The bounds of the layer.</p> required <code>paint</code> <code>Optional[Paint_]</code> <p>Optional paint to use when compositing the layer.</p> <code>None</code> <code>backdrop</code> <code>Optional[ImageFilter_]</code> <p>Optional backdrop filter to apply.</p> <code>None</code> <p>Returns:</p> Type Description <code>DisplayListBuilder_</code> <p>Self for method chaining.</p>"},{"location":"reference.html#impellerpy.DisplayListBuilder_.scale","title":"<code>scale(x, y)</code>","text":"<p>Apply a scale to the transformation matrix.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>The x scale factor.</p> required <code>y</code> <code>float</code> <p>The y scale factor.</p> required <p>Returns:</p> Type Description <code>DisplayListBuilder_</code> <p>Self for method chaining.</p>"},{"location":"reference.html#impellerpy.DisplayListBuilder_.set_transform","title":"<code>set_transform(xform)</code>","text":"<p>Clear the transformation on top of the save stack and replace it with a new value.</p> <p>Parameters:</p> Name Type Description Default <code>xform</code> <code>Matrix_</code> <p>The new transformation matrix.</p> required <p>Returns:</p> Type Description <code>DisplayListBuilder_</code> <p>Self for method chaining.</p>"},{"location":"reference.html#impellerpy.DisplayListBuilder_.translate","title":"<code>translate(x, y)</code>","text":"<p>Apply a translation to the transformation matrix.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>The x translation.</p> required <code>y</code> <code>float</code> <p>The y translation.</p> required <p>Returns:</p> Type Description <code>DisplayListBuilder_</code> <p>Self for method chaining.</p>"},{"location":"reference.html#impellerpy.DisplayList_","title":"<code>DisplayList_</code>","text":"<p>Represents encoded rendering intent.</p> <p>Display lists are immutable, reusable, thread-safe, and context-agnostic. They encapsulate a series of drawing commands that can be executed on a surface.</p> <p>While it is perfectly fine to create new display lists per frame, there may be opportunities for optimization when display lists are reused multiple times.</p>"},{"location":"reference.html#impellerpy.DrawStyle","title":"<code>DrawStyle</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Determines how shapes are rendered.</p>"},{"location":"reference.html#impellerpy.DrawStyle.FILL","title":"<code>FILL = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Fill the shape with the paint.</p>"},{"location":"reference.html#impellerpy.DrawStyle.STROKE","title":"<code>STROKE = 1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Stroke the outline of the shape with the paint.</p>"},{"location":"reference.html#impellerpy.DrawStyle.STROKE_AND_FILL","title":"<code>STROKE_AND_FILL = 2</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Both fill and stroke the shape with the paint.</p>"},{"location":"reference.html#impellerpy.FillType","title":"<code>FillType</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Determines how overlapping contours in a path are filled.</p>"},{"location":"reference.html#impellerpy.FillType.NON_ZERO","title":"<code>NON_ZERO = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Uses the non-zero winding rule for filling paths.</p>"},{"location":"reference.html#impellerpy.FillType.ODD","title":"<code>ODD = 1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Uses the even-odd rule for filling paths.</p>"},{"location":"reference.html#impellerpy.FontStyle","title":"<code>FontStyle</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Specifies the style of a font.</p>"},{"location":"reference.html#impellerpy.FontStyle.ITALIC","title":"<code>ITALIC = 1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Italic font style.</p>"},{"location":"reference.html#impellerpy.FontStyle.NORMAL","title":"<code>NORMAL = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Regular font style.</p>"},{"location":"reference.html#impellerpy.FontWeight","title":"<code>FontWeight</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Specifies the weight (boldness) of a font.</p>"},{"location":"reference.html#impellerpy.FontWeight.W100","title":"<code>W100 = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Thin</p>"},{"location":"reference.html#impellerpy.FontWeight.W200","title":"<code>W200 = 1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Light</p>"},{"location":"reference.html#impellerpy.FontWeight.W300","title":"<code>W300 = 2</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Light</p>"},{"location":"reference.html#impellerpy.FontWeight.W400","title":"<code>W400 = 3</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Regular</p>"},{"location":"reference.html#impellerpy.FontWeight.W500","title":"<code>W500 = 4</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Medium</p>"},{"location":"reference.html#impellerpy.FontWeight.W600","title":"<code>W600 = 5</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>bold</p>"},{"location":"reference.html#impellerpy.FontWeight.W700","title":"<code>W700 = 6</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Bold</p>"},{"location":"reference.html#impellerpy.FontWeight.W800","title":"<code>W800 = 7</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Bold</p>"},{"location":"reference.html#impellerpy.FontWeight.W900","title":"<code>W900 = 8</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Black</p>"},{"location":"reference.html#impellerpy.GlyphInfo","title":"<code>GlyphInfo</code>","text":"<p>               Bases: <code>GlyphInfo_</code></p>"},{"location":"reference.html#impellerpy.GlyphInfo_","title":"<code>GlyphInfo_</code>","text":"<p>Describes the metrics of glyphs in a paragraph line.</p> <p>Provides information about a specific glyph in a paragraph, including its position, bounds, and text properties.</p>"},{"location":"reference.html#impellerpy.GlyphInfo_.grapheme_cluster_bounds","title":"<code>grapheme_cluster_bounds()</code>","text":"<p>Get the bounds of the grapheme cluster in the coordinate space of the paragraph.</p> <p>Returns:</p> Type Description <code>Rect_</code> <p>The grapheme cluster bounds.</p>"},{"location":"reference.html#impellerpy.GlyphInfo_.grapheme_cluster_code_unit_range_begin","title":"<code>grapheme_cluster_code_unit_range_begin()</code>","text":"<p>Get the start index in the buffer of UTF-16 code units for the grapheme cluster.</p> <p>Returns:</p> Type Description <code>int</code> <p>The UTF-16 code units start index.</p>"},{"location":"reference.html#impellerpy.GlyphInfo_.grapheme_cluster_code_unit_range_end","title":"<code>grapheme_cluster_code_unit_range_end()</code>","text":"<p>Get the end index in the buffer of UTF-16 code units for the grapheme cluster.</p> <p>Returns:</p> Type Description <code>int</code> <p>The UTF-16 code units end index.</p>"},{"location":"reference.html#impellerpy.GlyphInfo_.is_ellipsis","title":"<code>is_ellipsis()</code>","text":"<p>Check if the glyph represents an ellipsis.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the glyph is an ellipsis, False otherwise.</p>"},{"location":"reference.html#impellerpy.GlyphInfo_.text_direction","title":"<code>text_direction()</code>","text":"<p>Get the direction of the run that contains the glyph.</p> <p>Returns:</p> Type Description <code>TextDirection</code> <p>The text direction.</p>"},{"location":"reference.html#impellerpy.ISize","title":"<code>ISize</code>","text":"<p>               Bases: <code>ISize_</code></p>"},{"location":"reference.html#impellerpy.ISize.height","title":"<code>height = height</code>  <code>instance-attribute</code>","text":""},{"location":"reference.html#impellerpy.ISize.width","title":"<code>width = width</code>  <code>instance-attribute</code>","text":""},{"location":"reference.html#impellerpy.ISize.__init__","title":"<code>__init__(width=0, height=0)</code>","text":""},{"location":"reference.html#impellerpy.ISize_","title":"<code>ISize_</code>","text":"<p>Represents a 2D size with integer width and height.</p> <p>Attributes:</p> Name Type Description <code>width</code> <code>int</code> <p>The width component of the size (integer).</p> <code>height</code> <code>int</code> <p>The height component of the size (integer).</p>"},{"location":"reference.html#impellerpy.ISize_.height","title":"<code>height</code>  <code>instance-attribute</code>","text":""},{"location":"reference.html#impellerpy.ISize_.width","title":"<code>width</code>  <code>instance-attribute</code>","text":""},{"location":"reference.html#impellerpy.ISize_.__init__","title":"<code>__init__()</code>","text":"<p>Initialize an integer size with default values (0,0).</p>"},{"location":"reference.html#impellerpy.ImageFilter","title":"<code>ImageFilter</code>","text":"<p>               Bases: <code>ImageFilter_</code></p>"},{"location":"reference.html#impellerpy.ImageFilter_","title":"<code>ImageFilter_</code>","text":"<p>A filter that transforms images before they are drawn.</p> <p>Image filters are functions that are applied to regions of a texture to produce a single color. Contrast this with color filters that operate independently on a per-pixel basis.</p>"},{"location":"reference.html#impellerpy.ImageFilter_.blur","title":"<code>blur(x_sigma, y_sigma, tile_mode)</code>  <code>staticmethod</code>","text":"<p>Create an image filter that applies a Gaussian blur.</p> <p>The Gaussian blur applied may be an approximation for performance.</p> <p>Parameters:</p> Name Type Description Default <code>x_sigma</code> <code>float</code> <p>The standard deviation of the blur in the x direction.</p> required <code>y_sigma</code> <code>float</code> <p>The standard deviation of the blur in the y direction.</p> required <code>tile_mode</code> <code>TileMode</code> <p>How to handle coordinates outside the source image.</p> required <p>Returns:</p> Type Description <code>ImageFilter_</code> <p>A new image filter that applies a Gaussian blur.</p>"},{"location":"reference.html#impellerpy.ImageFilter_.compose","title":"<code>compose(outer, inner)</code>  <code>staticmethod</code>","text":"<p>Create a composed filter that applies inner then outer filters.</p> <p>The resulting filter is equivalent to: destination = outer_filter(inner_filter(source))</p> <p>Parameters:</p> Name Type Description Default <code>outer</code> <code>ImageFilter_</code> <p>The outer image filter to apply second.</p> required <code>inner</code> <code>ImageFilter_</code> <p>The inner image filter to apply first.</p> required <p>Returns:</p> Type Description <code>ImageFilter_</code> <p>A new image filter that applies both filters in sequence.</p>"},{"location":"reference.html#impellerpy.ImageFilter_.dilate","title":"<code>dilate(x_radius, y_radius)</code>  <code>staticmethod</code>","text":"<p>Create an image filter that enhances pixel values to the maximum in a region.</p> <p>This filter enhances the per-channel pixel values to the maximum value in a circle around the pixel.</p> <p>Parameters:</p> Name Type Description Default <code>x_radius</code> <code>float</code> <p>The radius in the x direction.</p> required <code>y_radius</code> <code>float</code> <p>The radius in the y direction.</p> required <p>Returns:</p> Type Description <code>ImageFilter_</code> <p>A new image filter that performs dilation.</p>"},{"location":"reference.html#impellerpy.ImageFilter_.erode","title":"<code>erode(x_radius, y_radius)</code>  <code>staticmethod</code>","text":"<p>Create an image filter that dampens pixel values to the minimum in a region.</p> <p>This filter dampens the per-channel pixel values to the minimum value in a circle around the pixel.</p> <p>Parameters:</p> Name Type Description Default <code>x_radius</code> <code>float</code> <p>The radius in the x direction.</p> required <code>y_radius</code> <code>float</code> <p>The radius in the y direction.</p> required <p>Returns:</p> Type Description <code>ImageFilter_</code> <p>A new image filter that performs erosion.</p>"},{"location":"reference.html#impellerpy.ImageFilter_.matrix","title":"<code>matrix(matrix, sampling)</code>  <code>staticmethod</code>","text":"<p>Create an image filter that applies a transformation matrix to the image.</p> <p>Parameters:</p> Name Type Description Default <code>matrix</code> <code>Matrix_</code> <p>The transformation matrix to apply.</p> required <code>sampling</code> <code>TextureSampling</code> <p>The sampling method to use when reading the transformed image.</p> required <p>Returns:</p> Type Description <code>ImageFilter_</code> <p>A new image filter that applies the specified transformation.</p>"},{"location":"reference.html#impellerpy.LineMetrics","title":"<code>LineMetrics</code>","text":"<p>               Bases: <code>LineMetrics_</code></p>"},{"location":"reference.html#impellerpy.LineMetrics_","title":"<code>LineMetrics_</code>","text":"<p>Describes the metrics of lines in a fully laid out paragraph.</p> <p>Regardless of how the string of text is specified to the paragraph builder, offsets into buffers that are returned by line metrics are always assumed to be into buffers of UTF-16 code units.</p>"},{"location":"reference.html#impellerpy.LineMetrics_.ascent","title":"<code>ascent(line)</code>","text":"<p>Get the rise from the baseline as calculated from the font and style for this line.</p> <p>Parameters:</p> Name Type Description Default <code>line</code> <code>int</code> <p>The line index (zero based).</p> required <p>Returns:</p> Type Description <code>float</code> <p>The ascent value.</p>"},{"location":"reference.html#impellerpy.LineMetrics_.baseline","title":"<code>baseline(line)</code>","text":"<p>Get the y coordinate of the baseline for this line from the top of the paragraph.</p> <p>Parameters:</p> Name Type Description Default <code>line</code> <code>int</code> <p>The line index (zero based).</p> required <p>Returns:</p> Type Description <code>float</code> <p>The baseline position.</p>"},{"location":"reference.html#impellerpy.LineMetrics_.code_unit_end_index","title":"<code>code_unit_end_index(line)</code>","text":"<p>Get the end index in the buffer of UTF-16 code units for this line.</p> <p>Parameters:</p> Name Type Description Default <code>line</code> <code>int</code> <p>The line index (zero based).</p> required <p>Returns:</p> Type Description <code>int</code> <p>The UTF-16 code units end index.</p>"},{"location":"reference.html#impellerpy.LineMetrics_.code_unit_end_index_excluding_whitespace","title":"<code>code_unit_end_index_excluding_whitespace(line)</code>","text":"<p>Get the end index (excluding whitespace) in the buffer of UTF-16 code units.</p> <p>Parameters:</p> Name Type Description Default <code>line</code> <code>int</code> <p>The line index (zero based).</p> required <p>Returns:</p> Type Description <code>int</code> <p>The UTF-16 code units end index excluding whitespace.</p>"},{"location":"reference.html#impellerpy.LineMetrics_.code_unit_end_index_including_newline","title":"<code>code_unit_end_index_including_newline(line)</code>","text":"<p>Get the end index (including newlines) in the buffer of UTF-16 code units.</p> <p>Parameters:</p> Name Type Description Default <code>line</code> <code>int</code> <p>The line index (zero based).</p> required <p>Returns:</p> Type Description <code>int</code> <p>The UTF-16 code units end index including newlines.</p>"},{"location":"reference.html#impellerpy.LineMetrics_.code_unit_start_index","title":"<code>code_unit_start_index(line)</code>","text":"<p>Get the start index in the buffer of UTF-16 code units for this line.</p> <p>Parameters:</p> Name Type Description Default <code>line</code> <code>int</code> <p>The line index (zero based).</p> required <p>Returns:</p> Type Description <code>int</code> <p>The UTF-16 code units start index.</p>"},{"location":"reference.html#impellerpy.LineMetrics_.descent","title":"<code>descent(line)</code>","text":"<p>Get the drop from the baseline as calculated from the font and style for this line.</p> <p>Parameters:</p> Name Type Description Default <code>line</code> <code>int</code> <p>The line index (zero based).</p> required <p>Returns:</p> Type Description <code>float</code> <p>The descent value.</p>"},{"location":"reference.html#impellerpy.LineMetrics_.height","title":"<code>height(line)</code>","text":"<p>Get the total height of the line from the top edge to the bottom edge.</p> <p>Parameters:</p> Name Type Description Default <code>line</code> <code>int</code> <p>The line index (zero based).</p> required <p>Returns:</p> Type Description <code>float</code> <p>The height of the line.</p>"},{"location":"reference.html#impellerpy.LineMetrics_.is_hardbreak","title":"<code>is_hardbreak(line)</code>","text":"<p>Check if this line ends with an explicit line break or is the end of the paragraph.</p> <p>Parameters:</p> Name Type Description Default <code>line</code> <code>int</code> <p>The line index (zero based).</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the line is a hard break, False otherwise.</p>"},{"location":"reference.html#impellerpy.LineMetrics_.left","title":"<code>left(line)</code>","text":"<p>Get the x coordinate of left edge of the line.</p> <p>Parameters:</p> Name Type Description Default <code>line</code> <code>int</code> <p>The line index (zero based).</p> required <p>Returns:</p> Type Description <code>float</code> <p>The left edge coordinate.</p>"},{"location":"reference.html#impellerpy.LineMetrics_.unscaled_ascent","title":"<code>unscaled_ascent(line)</code>","text":"<p>Get the rise from the baseline as calculated from the font and style for this line.</p> <p>This ignores the height from the text style.</p> <p>Parameters:</p> Name Type Description Default <code>line</code> <code>int</code> <p>The line index (zero based).</p> required <p>Returns:</p> Type Description <code>float</code> <p>The unscaled ascent value.</p>"},{"location":"reference.html#impellerpy.LineMetrics_.width","title":"<code>width(line)</code>","text":"<p>Get the width of the line from the left edge of the leftmost glyph to the right edge.</p> <p>Parameters:</p> Name Type Description Default <code>line</code> <code>int</code> <p>The line index (zero based).</p> required <p>Returns:</p> Type Description <code>float</code> <p>The width of the line.</p>"},{"location":"reference.html#impellerpy.MaskFilter","title":"<code>MaskFilter</code>","text":"<p>               Bases: <code>MaskFilter_</code></p>"},{"location":"reference.html#impellerpy.MaskFilter_","title":"<code>MaskFilter_</code>","text":"<p>A filter applied to a shape's mask before drawing.</p> <p>Mask filters are functions that are applied over a shape after it has been drawn but before it has been blended into the final image.</p>"},{"location":"reference.html#impellerpy.MaskFilter_.blur","title":"<code>blur(style, sigma)</code>  <code>staticmethod</code>","text":"<p>Create a mask filter that blurs contents in the masked shape.</p> <p>Parameters:</p> Name Type Description Default <code>style</code> <code>BlurStyle</code> <p>The style of blur to apply.</p> required <code>sigma</code> <code>float</code> <p>The standard deviation of the blur.</p> required <p>Returns:</p> Type Description <code>MaskFilter_</code> <p>A new mask filter that applies the specified blur.</p>"},{"location":"reference.html#impellerpy.Matrix","title":"<code>Matrix</code>","text":"<p>               Bases: <code>Matrix_</code></p>"},{"location":"reference.html#impellerpy.Matrix.__init__","title":"<code>__init__(row_col_list)</code>","text":""},{"location":"reference.html#impellerpy.Matrix.identity","title":"<code>identity()</code>  <code>staticmethod</code>","text":""},{"location":"reference.html#impellerpy.Matrix.with_diagonal","title":"<code>with_diagonal(diagonal)</code>  <code>staticmethod</code>","text":""},{"location":"reference.html#impellerpy.Matrix_","title":"<code>Matrix_</code>","text":"<p>A 4x4 transformation matrix using column-major storage.</p> <p>The matrix is stored as: | m[0] m[4] m[8]  m[12] | | m[1] m[5] m[9]  m[13] | | m[2] m[6] m[10] m[14] | | m[3] m[7] m[11] m[15] |</p>"},{"location":"reference.html#impellerpy.Matrix_.__getitem__","title":"<code>__getitem__(key)</code>","text":"<p>Get the value at the specified index.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>int</code> <p>The index (0-15) to retrieve.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The float value at the specified index.</p>"},{"location":"reference.html#impellerpy.Matrix_.__init__","title":"<code>__init__(values)</code>","text":"<p>Initialize a matrix with the provided values.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>List[float]</code> <p>A list of 16 float values in column-major order.</p> required"},{"location":"reference.html#impellerpy.Matrix_.__setitem__","title":"<code>__setitem__(key, value)</code>","text":"<p>Set the value at the specified index.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>int</code> <p>The index (0-15) to modify.</p> required <code>value</code> <code>float</code> <p>The new float value to set.</p> required"},{"location":"reference.html#impellerpy.Matrix_.to_list","title":"<code>to_list()</code>","text":"<p>Convert the matrix to a list of float values.</p> <p>Returns:</p> Type Description <code>List[float]</code> <p>A list of 16 float values representing the matrix in column-major order.</p>"},{"location":"reference.html#impellerpy.Paint","title":"<code>Paint</code>","text":"<p>               Bases: <code>Paint_</code></p>"},{"location":"reference.html#impellerpy.Paint_","title":"<code>Paint_</code>","text":"<p>Controls the visual properties of drawing operations.</p> <p>Paints define how shapes and text are rendered, including color, stroke style, blend mode, and various filters.</p>"},{"location":"reference.html#impellerpy.Paint_.__init__","title":"<code>__init__()</code>","text":"<p>Initialize a paint with default values.</p>"},{"location":"reference.html#impellerpy.Paint_.set_blend_mode","title":"<code>set_blend_mode(blend_mode)</code>","text":"<p>Set the paint blend mode.</p> <p>The blend mode controls how the new paint contents are mixed with the values already drawn using previous draw calls.</p> <p>Parameters:</p> Name Type Description Default <code>blend_mode</code> <code>BlendMode</code> <p>The blend mode to use.</p> required <p>Returns:</p> Type Description <code>Paint_</code> <p>Self for method chaining.</p>"},{"location":"reference.html#impellerpy.Paint_.set_color","title":"<code>set_color(color)</code>","text":"<p>Set the paint color.</p> <p>Parameters:</p> Name Type Description Default <code>color</code> <code>Color_</code> <p>The color to use for drawing.</p> required <p>Returns:</p> Type Description <code>Paint_</code> <p>Self for method chaining.</p>"},{"location":"reference.html#impellerpy.Paint_.set_color_filter","title":"<code>set_color_filter(filter)</code>","text":"<p>Set the color filter of the paint.</p> <p>Color filters are functions that take two colors and mix them to produce a single color. This color is then usually merged with the destination during blending.</p> <p>Parameters:</p> Name Type Description Default <code>filter</code> <code>ColorFilter_</code> <p>The color filter to use.</p> required <p>Returns:</p> Type Description <code>Paint_</code> <p>Self for method chaining.</p>"},{"location":"reference.html#impellerpy.Paint_.set_color_source","title":"<code>set_color_source(source)</code>","text":"<p>Set the color source of the paint.</p> <p>Color sources are functions that generate colors for each texture element covered by a draw call.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>ColorSource_</code> <p>The color source to use.</p> required <p>Returns:</p> Type Description <code>Paint_</code> <p>Self for method chaining.</p>"},{"location":"reference.html#impellerpy.Paint_.set_draw_style","title":"<code>set_draw_style(style)</code>","text":"<p>Set the paint draw style.</p> <p>The style controls if the closed shapes are filled and/or stroked.</p> <p>Parameters:</p> Name Type Description Default <code>style</code> <code>DrawStyle</code> <p>The draw style to use.</p> required <p>Returns:</p> Type Description <code>Paint_</code> <p>Self for method chaining.</p>"},{"location":"reference.html#impellerpy.Paint_.set_image_filter","title":"<code>set_image_filter(filter)</code>","text":"<p>Set the image filter of the paint.</p> <p>Image filters are functions that are applied to regions of a texture to produce a single color.</p> <p>Parameters:</p> Name Type Description Default <code>filter</code> <code>ImageFilter_</code> <p>The image filter to use.</p> required <p>Returns:</p> Type Description <code>Paint_</code> <p>Self for method chaining.</p>"},{"location":"reference.html#impellerpy.Paint_.set_mask_filter","title":"<code>set_mask_filter(filter)</code>","text":"<p>Set the mask filter of the paint.</p> <p>Mask filters are functions that are applied over a shape after it has been drawn but before it has been blended into the final image.</p> <p>Parameters:</p> Name Type Description Default <code>filter</code> <code>MaskFilter_</code> <p>The mask filter to use.</p> required <p>Returns:</p> Type Description <code>Paint_</code> <p>Self for method chaining.</p>"},{"location":"reference.html#impellerpy.Paint_.set_stroke_cap","title":"<code>set_stroke_cap(cap)</code>","text":"<p>Set how strokes rendered using this paint are capped.</p> <p>Parameters:</p> Name Type Description Default <code>cap</code> <code>StrokeCap</code> <p>The stroke cap style to use.</p> required <p>Returns:</p> Type Description <code>Paint_</code> <p>Self for method chaining.</p>"},{"location":"reference.html#impellerpy.Paint_.set_stroke_join","title":"<code>set_stroke_join(join)</code>","text":"<p>Set how strokes rendered using this paint are joined.</p> <p>Parameters:</p> Name Type Description Default <code>join</code> <code>StrokeJoin</code> <p>The stroke join style to use.</p> required <p>Returns:</p> Type Description <code>Paint_</code> <p>Self for method chaining.</p>"},{"location":"reference.html#impellerpy.Paint_.set_stroke_miter","title":"<code>set_stroke_miter(miter)</code>","text":"<p>Set the miter limit of the strokes rendered using this paint.</p> <p>The miter limit controls when a sharp corner is beveled.</p> <p>Parameters:</p> Name Type Description Default <code>miter</code> <code>float</code> <p>The miter limit value.</p> required <p>Returns:</p> Type Description <code>Paint_</code> <p>Self for method chaining.</p>"},{"location":"reference.html#impellerpy.Paint_.set_stroke_width","title":"<code>set_stroke_width(width)</code>","text":"<p>Set the width of the strokes rendered using this paint.</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>float</code> <p>The stroke width in pixels.</p> required <p>Returns:</p> Type Description <code>Paint_</code> <p>Self for method chaining.</p>"},{"location":"reference.html#impellerpy.Paragraph","title":"<code>Paragraph</code>","text":"<p>               Bases: <code>Paragraph_</code></p>"},{"location":"reference.html#impellerpy.ParagraphBuilder","title":"<code>ParagraphBuilder</code>","text":"<p>               Bases: <code>ParagraphBuilder_</code></p>"},{"location":"reference.html#impellerpy.ParagraphBuilder_","title":"<code>ParagraphBuilder_</code>","text":"<p>Allows for the creation of fully laid out paragraphs.</p> <p>To build a paragraph, users push/pop paragraph styles onto a stack then add UTF-8 encoded text. The properties on the top of paragraph style stack when the text is added are used to layout and shape that subset of the paragraph.</p>"},{"location":"reference.html#impellerpy.ParagraphBuilder_.__init__","title":"<code>__init__(type_context)</code>","text":"<p>Initialize a new paragraph builder.</p> <p>Parameters:</p> Name Type Description Default <code>type_context</code> <code>TypographyContext_</code> <p>The typography context to use.</p> required"},{"location":"reference.html#impellerpy.ParagraphBuilder_.add_text","title":"<code>add_text(text)</code>","text":"<p>Add UTF-8 encoded text to the paragraph.</p> <p>The text will be styled according to the paragraph style already on top of the paragraph style stack.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The text to add.</p> required <p>Returns:</p> Type Description <code>ParagraphBuilder_</code> <p>Self for method chaining.</p>"},{"location":"reference.html#impellerpy.ParagraphBuilder_.build","title":"<code>build(width)</code>","text":"<p>Layout and build a new paragraph using the specified width.</p> <p>The resulting paragraph is immutable. The paragraph builder must be discarded and a new one created to build more paragraphs.</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>float</code> <p>The paragraph width in logical pixels.</p> required <p>Returns:</p> Type Description <code>Paragraph_</code> <p>A new paragraph.</p>"},{"location":"reference.html#impellerpy.ParagraphBuilder_.pop_style","title":"<code>pop_style()</code>","text":"<p>Pop a previously pushed paragraph style from the paragraph style stack.</p> <p>Returns:</p> Type Description <code>ParagraphBuilder_</code> <p>Self for method chaining.</p>"},{"location":"reference.html#impellerpy.ParagraphBuilder_.push_style","title":"<code>push_style(style)</code>","text":"<p>Push a new paragraph style onto the paragraph style stack.</p> <p>Not all paragraph styles can be combined. For instance, it does not make sense to mix text alignment for different text runs within a paragraph. In such cases, the preference of the first paragraph style on the style stack will take hold.</p> <p>Parameters:</p> Name Type Description Default <code>style</code> <code>ParagraphStyle_</code> <p>The paragraph style to push.</p> required <p>Returns:</p> Type Description <code>ParagraphBuilder_</code> <p>Self for method chaining.</p>"},{"location":"reference.html#impellerpy.ParagraphStyle","title":"<code>ParagraphStyle</code>","text":"<p>               Bases: <code>ParagraphStyle_</code></p>"},{"location":"reference.html#impellerpy.ParagraphStyle_","title":"<code>ParagraphStyle_</code>","text":"<p>Specifies the style properties for text in a paragraph.</p> <p>Paragraph styles are managed in a stack with specify text properties to apply to text that is added to the paragraph builder.</p>"},{"location":"reference.html#impellerpy.ParagraphStyle_.__init__","title":"<code>__init__()</code>","text":"<p>Initialize a new paragraph style with default values.</p>"},{"location":"reference.html#impellerpy.ParagraphStyle_.set_background","title":"<code>set_background(paint)</code>","text":"<p>Set the paint used to render the background of the text glyphs.</p> <p>Parameters:</p> Name Type Description Default <code>paint</code> <code>Paint_</code> <p>The paint to use for the background.</p> required <p>Returns:</p> Type Description <code>ParagraphStyle_</code> <p>Self for method chaining.</p>"},{"location":"reference.html#impellerpy.ParagraphStyle_.set_font_family","title":"<code>set_font_family(family)</code>","text":"<p>Set the font family.</p> <p>Parameters:</p> Name Type Description Default <code>family</code> <code>str</code> <p>The font family name.</p> required <p>Returns:</p> Type Description <code>ParagraphStyle_</code> <p>Self for method chaining.</p>"},{"location":"reference.html#impellerpy.ParagraphStyle_.set_font_foreground","title":"<code>set_font_foreground(paint)</code>","text":"<p>Set the paint used to render the text glyph contents.</p> <p>Parameters:</p> Name Type Description Default <code>paint</code> <code>Paint_</code> <p>The paint to use for the text.</p> required <p>Returns:</p> Type Description <code>ParagraphStyle_</code> <p>Self for method chaining.</p>"},{"location":"reference.html#impellerpy.ParagraphStyle_.set_font_size","title":"<code>set_font_size(size)</code>","text":"<p>Set the font size.</p> <p>Parameters:</p> Name Type Description Default <code>size</code> <code>float</code> <p>The font size in logical pixels.</p> required <p>Returns:</p> Type Description <code>ParagraphStyle_</code> <p>Self for method chaining.</p>"},{"location":"reference.html#impellerpy.ParagraphStyle_.set_font_style","title":"<code>set_font_style(style)</code>","text":"<p>Set whether the glyphs should be bolded or italicized.</p> <p>Parameters:</p> Name Type Description Default <code>style</code> <code>FontStyle</code> <p>The font style.</p> required <p>Returns:</p> Type Description <code>ParagraphStyle_</code> <p>Self for method chaining.</p>"},{"location":"reference.html#impellerpy.ParagraphStyle_.set_font_weight","title":"<code>set_font_weight(weight)</code>","text":"<p>Set the weight of the font to select when rendering glyphs.</p> <p>Parameters:</p> Name Type Description Default <code>weight</code> <code>FontWeight</code> <p>The font weight.</p> required <p>Returns:</p> Type Description <code>ParagraphStyle_</code> <p>Self for method chaining.</p>"},{"location":"reference.html#impellerpy.ParagraphStyle_.set_height","title":"<code>set_height(height)</code>","text":"<p>Set the height of the text as a multiple of text size.</p> <p>When height is 0.0, the line height will be determined by the font's metrics directly, which may differ from the font size. Otherwise the line height of the text will be a multiple of font size, and be exactly fontSize * height logical pixels tall.</p> <p>Parameters:</p> Name Type Description Default <code>height</code> <code>float</code> <p>The height multiplier.</p> required <p>Returns:</p> Type Description <code>ParagraphStyle_</code> <p>Self for method chaining.</p>"},{"location":"reference.html#impellerpy.ParagraphStyle_.set_locale","title":"<code>set_locale(locale)</code>","text":"<p>Set the paragraph locale.</p> <p>Parameters:</p> Name Type Description Default <code>locale</code> <code>str</code> <p>The locale string (e.g., \"en_US\").</p> required <p>Returns:</p> Type Description <code>ParagraphStyle_</code> <p>Self for method chaining.</p>"},{"location":"reference.html#impellerpy.ParagraphStyle_.set_max_lines","title":"<code>set_max_lines(count)</code>","text":"<p>Set the maximum line count within the paragraph.</p> <p>Parameters:</p> Name Type Description Default <code>count</code> <code>int</code> <p>The maximum number of lines.</p> required <p>Returns:</p> Type Description <code>ParagraphStyle_</code> <p>Self for method chaining.</p>"},{"location":"reference.html#impellerpy.ParagraphStyle_.set_text_alignment","title":"<code>set_text_alignment(align)</code>","text":"<p>Set the alignment of text within the paragraph.</p> <p>Parameters:</p> Name Type Description Default <code>align</code> <code>TextAlignment</code> <p>The text alignment.</p> required <p>Returns:</p> Type Description <code>ParagraphStyle_</code> <p>Self for method chaining.</p>"},{"location":"reference.html#impellerpy.ParagraphStyle_.set_text_direction","title":"<code>set_text_direction(direction)</code>","text":"<p>Set the directionality of the text within the paragraph.</p> <p>Parameters:</p> Name Type Description Default <code>direction</code> <code>TextDirection</code> <p>The text direction.</p> required <p>Returns:</p> Type Description <code>ParagraphStyle_</code> <p>Self for method chaining.</p>"},{"location":"reference.html#impellerpy.Paragraph_","title":"<code>Paragraph_</code>","text":"<p>An immutable, fully laid out paragraph of text.</p> <p>Paragraphs are created by paragraph builders and contain the complete layout information for a block of text, including line breaks, font metrics, and glyph positioning.</p>"},{"location":"reference.html#impellerpy.Paragraph_.alphabetic_baseline","title":"<code>alphabetic_baseline()</code>","text":"<p>Get the distance from the top of the paragraph to the alphabetic baseline of the first line.</p> <p>This is used for alphabetic fonts (A-Z, a-z, Greek, etc.).</p> <p>Returns:</p> Type Description <code>float</code> <p>The alphabetic baseline distance.</p>"},{"location":"reference.html#impellerpy.Paragraph_.glyph_info_at_code_unit_index","title":"<code>glyph_info_at_code_unit_index(code_unit_index)</code>","text":"<p>Get information about the glyph at the given UTF-16 code unit index.</p> <p>Parameters:</p> Name Type Description Default <code>code_unit_index</code> <code>int</code> <p>The UTF-16 code unit index.</p> required <p>Returns:</p> Type Description <code>GlyphInfo_</code> <p>The glyph information.</p>"},{"location":"reference.html#impellerpy.Paragraph_.glyph_info_at_paragraph_coordinate","title":"<code>glyph_info_at_paragraph_coordinate(x, y)</code>","text":"<p>Get information about the glyph closest to the specified coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>The x coordinate relative to paragraph origin.</p> required <code>y</code> <code>float</code> <p>The y coordinate relative to paragraph origin.</p> required <p>Returns:</p> Type Description <code>GlyphInfo_</code> <p>The glyph information.</p>"},{"location":"reference.html#impellerpy.Paragraph_.height","title":"<code>height()</code>","text":"<p>Get the height of the laid out paragraph.</p> <p>This is not a tight bounding box and some glyphs may not reach the minimum location they are allowed to reach.</p> <p>Returns:</p> Type Description <code>float</code> <p>The height of the paragraph.</p>"},{"location":"reference.html#impellerpy.Paragraph_.ideographic_baseline","title":"<code>ideographic_baseline()</code>","text":"<p>Get the distance from the top of the paragraph to the ideographic baseline of the first line.</p> <p>This is used for ideographic fonts (Japanese, Korean, etc.).</p> <p>Returns:</p> Type Description <code>float</code> <p>The ideographic baseline distance.</p>"},{"location":"reference.html#impellerpy.Paragraph_.line_count","title":"<code>line_count()</code>","text":"<p>Get the number of lines visible in the paragraph after line breaking.</p> <p>Returns:</p> Type Description <code>int</code> <p>The number of lines.</p>"},{"location":"reference.html#impellerpy.Paragraph_.line_metrics","title":"<code>line_metrics()</code>","text":"<p>Get the line metrics of this laid out paragraph.</p> <p>Calculating the line metrics is expensive. The first time line metrics are requested, they will be cached along with the paragraph (which is immutable).</p> <p>Returns:</p> Type Description <code>LineMetrics_</code> <p>The line metrics.</p>"},{"location":"reference.html#impellerpy.Paragraph_.longest_line_width","title":"<code>longest_line_width()</code>","text":"<p>Get the length of the longest line in the paragraph.</p> <p>This is the horizontal distance between the left edge of the leftmost glyph and the right edge of the rightmost glyph, in the longest line in the paragraph.</p> <p>Returns:</p> Type Description <code>float</code> <p>The width of the longest line.</p>"},{"location":"reference.html#impellerpy.Paragraph_.max_intrinsic_width","title":"<code>max_intrinsic_width()</code>","text":"<p>Get the width of the paragraph without line breaking.</p> <p>Returns:</p> Type Description <code>float</code> <p>The maximum intrinsic width.</p>"},{"location":"reference.html#impellerpy.Paragraph_.max_width","title":"<code>max_width()</code>","text":"<p>Get the width provided to the paragraph builder during layout.</p> <p>This is the maximum width any line in the laid out paragraph can occupy. But, it is not necessarily the actual width of the paragraph after layout.</p> <p>Returns:</p> Type Description <code>float</code> <p>The maximum width.</p>"},{"location":"reference.html#impellerpy.Paragraph_.min_intrinsic_width","title":"<code>min_intrinsic_width()</code>","text":"<p>Get the actual width of the longest line in the paragraph after layout.</p> <p>This is expected to be less than or equal to max_width().</p> <p>Returns:</p> Type Description <code>float</code> <p>The minimum intrinsic width.</p>"},{"location":"reference.html#impellerpy.Paragraph_.word_boundary","title":"<code>word_boundary(code_unit_index)</code>","text":"<p>Get the range into the UTF-16 code unit buffer that represents the word.</p> <p>Word boundaries are defined more precisely in Unicode Standard Annex #29.</p> <p>Parameters:</p> Name Type Description Default <code>code_unit_index</code> <code>int</code> <p>The code unit index.</p> required <p>Returns:</p> Type Description <code>Range_</code> <p>The range representing the word boundary.</p>"},{"location":"reference.html#impellerpy.Path","title":"<code>Path</code>","text":"<p>               Bases: <code>Path_</code></p>"},{"location":"reference.html#impellerpy.PathBuilder","title":"<code>PathBuilder</code>","text":"<p>               Bases: <code>PathBuilder_</code></p>"},{"location":"reference.html#impellerpy.PathBuilder_","title":"<code>PathBuilder_</code>","text":"<p>Allows for the incremental building of paths.</p> <p>Path builders create immutable Path objects that can be used for drawing and clipping operations.</p>"},{"location":"reference.html#impellerpy.PathBuilder_.__init__","title":"<code>__init__()</code>","text":"<p>Initialize a new path builder.</p>"},{"location":"reference.html#impellerpy.PathBuilder_.add_arc","title":"<code>add_arc(rect, start_degrees, end_degrees)</code>","text":"<p>Add an arc to the path.</p> <p>Parameters:</p> Name Type Description Default <code>rect</code> <code>Rect_</code> <p>The rectangle defining the oval bounds of the arc.</p> required <code>start_degrees</code> <code>float</code> <p>The starting angle in degrees.</p> required <code>end_degrees</code> <code>float</code> <p>The ending angle in degrees.</p> required <p>Returns:</p> Type Description <code>PathBuilder_</code> <p>Self for method chaining.</p>"},{"location":"reference.html#impellerpy.PathBuilder_.add_oval","title":"<code>add_oval(oval_bounds)</code>","text":"<p>Add an oval to the path.</p> <p>Parameters:</p> Name Type Description Default <code>oval_bounds</code> <code>Rect_</code> <p>The rectangle defining the oval bounds.</p> required <p>Returns:</p> Type Description <code>PathBuilder_</code> <p>Self for method chaining.</p>"},{"location":"reference.html#impellerpy.PathBuilder_.add_rect","title":"<code>add_rect(rect)</code>","text":"<p>Add a rectangle to the path.</p> <p>Parameters:</p> Name Type Description Default <code>rect</code> <code>Rect_</code> <p>The rectangle to add.</p> required <p>Returns:</p> Type Description <code>PathBuilder_</code> <p>Self for method chaining.</p>"},{"location":"reference.html#impellerpy.PathBuilder_.add_rounded_rect","title":"<code>add_rounded_rect(rect, radii)</code>","text":"<p>Add a rounded rectangle to the path.</p> <p>Parameters:</p> Name Type Description Default <code>rect</code> <code>Rect_</code> <p>The rectangle to add.</p> required <code>radii</code> <code>RoundingRadii_</code> <p>The corner radii of the rectangle.</p> required <p>Returns:</p> Type Description <code>PathBuilder_</code> <p>Self for method chaining.</p>"},{"location":"reference.html#impellerpy.PathBuilder_.build","title":"<code>build(fill)</code>","text":"<p>Create a new path using the existing built-up path.</p> <p>The existing path builder now contains an empty path.</p> <p>Parameters:</p> Name Type Description Default <code>fill</code> <code>FillType</code> <p>The fill type to use for the path.</p> required <p>Returns:</p> Type Description <code>Path_</code> <p>A new path.</p>"},{"location":"reference.html#impellerpy.PathBuilder_.build_copy","title":"<code>build_copy(fill)</code>","text":"<p>Create a new path by copying the existing built-up path.</p> <p>The existing path can continue being added to.</p> <p>Parameters:</p> Name Type Description Default <code>fill</code> <code>FillType</code> <p>The fill type to use for the path.</p> required <p>Returns:</p> Type Description <code>Path_</code> <p>A new path.</p>"},{"location":"reference.html#impellerpy.PathBuilder_.close","title":"<code>close()</code>","text":"<p>Close the current subpath.</p> <p>This adds a line segment from the current point to the first point of the subpath.</p> <p>Returns:</p> Type Description <code>PathBuilder_</code> <p>Self for method chaining.</p>"},{"location":"reference.html#impellerpy.PathBuilder_.cubic_curve_to","title":"<code>cubic_curve_to(cp1, cp2, end)</code>","text":"<p>Add a cubic B\u00e9zier curve from the current point to the specified end point.</p> <p>Parameters:</p> Name Type Description Default <code>cp1</code> <code>Point_</code> <p>The first control point.</p> required <code>cp2</code> <code>Point_</code> <p>The second control point.</p> required <code>end</code> <code>Point_</code> <p>The end point.</p> required <p>Returns:</p> Type Description <code>PathBuilder_</code> <p>Self for method chaining.</p>"},{"location":"reference.html#impellerpy.PathBuilder_.line_to","title":"<code>line_to(location)</code>","text":"<p>Add a line segment from the current point to the specified location.</p> <p>Parameters:</p> Name Type Description Default <code>location</code> <code>Point_</code> <p>The end point of the line.</p> required <p>Returns:</p> Type Description <code>PathBuilder_</code> <p>Self for method chaining.</p>"},{"location":"reference.html#impellerpy.PathBuilder_.move_to","title":"<code>move_to(location)</code>","text":"<p>Move the cursor to the specified location without adding a line segment.</p> <p>Parameters:</p> Name Type Description Default <code>location</code> <code>Point_</code> <p>The new cursor location.</p> required <p>Returns:</p> Type Description <code>PathBuilder_</code> <p>Self for method chaining.</p>"},{"location":"reference.html#impellerpy.PathBuilder_.quadratic_curve_to","title":"<code>quadratic_curve_to(cp, end)</code>","text":"<p>Add a quadratic B\u00e9zier curve from the current point to the specified end point.</p> <p>Parameters:</p> Name Type Description Default <code>cp</code> <code>Point_</code> <p>The control point.</p> required <code>end</code> <code>Point_</code> <p>The end point.</p> required <p>Returns:</p> Type Description <code>PathBuilder_</code> <p>Self for method chaining.</p>"},{"location":"reference.html#impellerpy.Path_","title":"<code>Path_</code>","text":"<p>Represents a two-dimensional path that is immutable and graphics context agnostic.</p> <p>Paths in Impeller consist of linear, cubic B\u00e9zier curve, and quadratic B\u00e9zier curve segments. All other shapes are approximations using these building blocks.</p> <p>Paths are created using path builders that allow for the configuration of the path segments, how they are filled, and/or stroked.</p>"},{"location":"reference.html#impellerpy.PixelFormat","title":"<code>PixelFormat</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Specifies the format of pixels in textures and surfaces.</p>"},{"location":"reference.html#impellerpy.PixelFormat.RGBA8888","title":"<code>RGBA8888 = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>8 bits per channel, red, green, blue, alpha.</p>"},{"location":"reference.html#impellerpy.Point","title":"<code>Point</code>","text":"<p>               Bases: <code>Point_</code></p>"},{"location":"reference.html#impellerpy.Point.x","title":"<code>x = x</code>  <code>instance-attribute</code>","text":""},{"location":"reference.html#impellerpy.Point.y","title":"<code>y = y</code>  <code>instance-attribute</code>","text":""},{"location":"reference.html#impellerpy.Point.__init__","title":"<code>__init__(x=0, y=0)</code>","text":""},{"location":"reference.html#impellerpy.Point_","title":"<code>Point_</code>","text":"<p>Represents a 2D point with x and y coordinates.</p> <p>Attributes:</p> Name Type Description <code>x</code> <code>float</code> <p>The x-coordinate of the point.</p> <code>y</code> <code>float</code> <p>The y-coordinate of the point.</p>"},{"location":"reference.html#impellerpy.Point_.x","title":"<code>x</code>  <code>instance-attribute</code>","text":""},{"location":"reference.html#impellerpy.Point_.y","title":"<code>y</code>  <code>instance-attribute</code>","text":""},{"location":"reference.html#impellerpy.Point_.__init__","title":"<code>__init__()</code>","text":"<p>Initialize a point with default values (0,0).</p>"},{"location":"reference.html#impellerpy.Range","title":"<code>Range</code>","text":"<p>               Bases: <code>Range_</code></p>"},{"location":"reference.html#impellerpy.Range.end","title":"<code>end = end</code>  <code>instance-attribute</code>","text":""},{"location":"reference.html#impellerpy.Range.start","title":"<code>start = start</code>  <code>instance-attribute</code>","text":""},{"location":"reference.html#impellerpy.Range.__init__","title":"<code>__init__(start=0, end=0)</code>","text":""},{"location":"reference.html#impellerpy.Range_","title":"<code>Range_</code>","text":"<p>Represents a range of values from start to end.</p> <p>Attributes:</p> Name Type Description <code>start</code> <code>int</code> <p>The start index of the range.</p> <code>end</code> <code>int</code> <p>The end index of the range.</p>"},{"location":"reference.html#impellerpy.Range_.end","title":"<code>end</code>  <code>instance-attribute</code>","text":""},{"location":"reference.html#impellerpy.Range_.start","title":"<code>start</code>  <code>instance-attribute</code>","text":""},{"location":"reference.html#impellerpy.Range_.__init__","title":"<code>__init__()</code>","text":"<p>Initialize a range with default values (0,0).</p>"},{"location":"reference.html#impellerpy.Rect","title":"<code>Rect</code>","text":"<p>               Bases: <code>Rect_</code></p>"},{"location":"reference.html#impellerpy.Rect.height","title":"<code>height = height</code>  <code>instance-attribute</code>","text":""},{"location":"reference.html#impellerpy.Rect.width","title":"<code>width = width</code>  <code>instance-attribute</code>","text":""},{"location":"reference.html#impellerpy.Rect.x","title":"<code>x = x</code>  <code>instance-attribute</code>","text":""},{"location":"reference.html#impellerpy.Rect.y","title":"<code>y = y</code>  <code>instance-attribute</code>","text":""},{"location":"reference.html#impellerpy.Rect.__init__","title":"<code>__init__(x=0, y=0, width=0, height=0)</code>","text":""},{"location":"reference.html#impellerpy.Rect_","title":"<code>Rect_</code>","text":"<p>Represents a rectangle with position and size.</p> <p>Attributes:</p> Name Type Description <code>x</code> <code>float</code> <p>The x-coordinate of the top-left corner.</p> <code>y</code> <code>float</code> <p>The y-coordinate of the top-left corner.</p> <code>width</code> <code>float</code> <p>The width of the rectangle.</p> <code>height</code> <code>float</code> <p>The height of the rectangle.</p>"},{"location":"reference.html#impellerpy.Rect_.height","title":"<code>height</code>  <code>instance-attribute</code>","text":""},{"location":"reference.html#impellerpy.Rect_.width","title":"<code>width</code>  <code>instance-attribute</code>","text":""},{"location":"reference.html#impellerpy.Rect_.x","title":"<code>x</code>  <code>instance-attribute</code>","text":""},{"location":"reference.html#impellerpy.Rect_.y","title":"<code>y</code>  <code>instance-attribute</code>","text":""},{"location":"reference.html#impellerpy.Rect_.__init__","title":"<code>__init__()</code>","text":"<p>Initialize a rectangle with default values (0,0,0,0).</p>"},{"location":"reference.html#impellerpy.RoundingRadii","title":"<code>RoundingRadii</code>","text":"<p>               Bases: <code>RoundingRadii_</code></p>"},{"location":"reference.html#impellerpy.RoundingRadii_","title":"<code>RoundingRadii_</code>","text":"<p>Specifies the radii for rounded corners of a rectangle.</p> <p>Attributes:</p> Name Type Description <code>top_left</code> <code>Point_</code> <p>The radius for the top-left corner.</p> <code>bottom_left</code> <code>Point_</code> <p>The radius for the bottom-left corner.</p> <code>top_right</code> <code>Point_</code> <p>The radius for the top-right corner.</p> <code>bottom_right</code> <code>Point_</code> <p>The radius for the bottom-right corner.</p>"},{"location":"reference.html#impellerpy.RoundingRadii_.bottom_left","title":"<code>bottom_left</code>  <code>instance-attribute</code>","text":""},{"location":"reference.html#impellerpy.RoundingRadii_.bottom_right","title":"<code>bottom_right</code>  <code>instance-attribute</code>","text":""},{"location":"reference.html#impellerpy.RoundingRadii_.top_left","title":"<code>top_left</code>  <code>instance-attribute</code>","text":""},{"location":"reference.html#impellerpy.RoundingRadii_.top_right","title":"<code>top_right</code>  <code>instance-attribute</code>","text":""},{"location":"reference.html#impellerpy.RoundingRadii_.__init__","title":"<code>__init__()</code>","text":"<p>Initialize rounding radii with default values (all corners set to 0,0).</p>"},{"location":"reference.html#impellerpy.Size","title":"<code>Size</code>","text":"<p>               Bases: <code>Size_</code></p>"},{"location":"reference.html#impellerpy.Size.height","title":"<code>height = height</code>  <code>instance-attribute</code>","text":""},{"location":"reference.html#impellerpy.Size.width","title":"<code>width = width</code>  <code>instance-attribute</code>","text":""},{"location":"reference.html#impellerpy.Size.__init__","title":"<code>__init__(width=0, height=0)</code>","text":""},{"location":"reference.html#impellerpy.Size_","title":"<code>Size_</code>","text":"<p>Represents a 2D size with width and height.</p> <p>Attributes:</p> Name Type Description <code>width</code> <code>float</code> <p>The width component of the size.</p> <code>height</code> <code>float</code> <p>The height component of the size.</p>"},{"location":"reference.html#impellerpy.Size_.height","title":"<code>height</code>  <code>instance-attribute</code>","text":""},{"location":"reference.html#impellerpy.Size_.width","title":"<code>width</code>  <code>instance-attribute</code>","text":""},{"location":"reference.html#impellerpy.Size_.__init__","title":"<code>__init__()</code>","text":"<p>Initialize a size with default values (0,0).</p>"},{"location":"reference.html#impellerpy.StrokeCap","title":"<code>StrokeCap</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Determines how the ends of stroked lines are rendered.</p>"},{"location":"reference.html#impellerpy.StrokeCap.BUTT","title":"<code>BUTT = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>End the stroke at the path's endpoint.</p>"},{"location":"reference.html#impellerpy.StrokeCap.ROUND","title":"<code>ROUND = 1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>End the stroke with a semicircle at the path's endpoint.</p>"},{"location":"reference.html#impellerpy.StrokeCap.SQUARE","title":"<code>SQUARE = 2</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>End the stroke with a square at the path's endpoint.</p>"},{"location":"reference.html#impellerpy.StrokeJoin","title":"<code>StrokeJoin</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Determines how corners in stroked paths are rendered.</p>"},{"location":"reference.html#impellerpy.StrokeJoin.BEVEL","title":"<code>BEVEL = 2</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Join segments with a flat corner.</p>"},{"location":"reference.html#impellerpy.StrokeJoin.MITER","title":"<code>MITER = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Join segments with a sharp corner.</p>"},{"location":"reference.html#impellerpy.StrokeJoin.ROUND","title":"<code>ROUND = 1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Join segments with a rounded corner.</p>"},{"location":"reference.html#impellerpy.Surface","title":"<code>Surface</code>","text":"<p>               Bases: <code>Surface_</code></p>"},{"location":"reference.html#impellerpy.Surface_","title":"<code>Surface_</code>","text":"<p>A render target for Impeller to direct rendering to.</p> <p>Surfaces are how Impeller API users perform Window System Integration (WSI). Users wrap swapchain images as surfaces and draw display lists onto these surfaces to present content.</p>"},{"location":"reference.html#impellerpy.Surface_.draw","title":"<code>draw(dl)</code>","text":"<p>Draw a display list onto the surface.</p> <p>The same display list can be drawn multiple times to different surfaces.</p> <p>Parameters:</p> Name Type Description Default <code>dl</code> <code>DisplayList_</code> <p>The display list to draw.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the display list was successfully drawn, False otherwise.</p>"},{"location":"reference.html#impellerpy.Surface_.present","title":"<code>present()</code>","text":"<p>Present the surface to the underlying window system.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the surface was successfully presented, False otherwise.</p>"},{"location":"reference.html#impellerpy.TextAlignment","title":"<code>TextAlignment</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Specifies the horizontal alignment of text.</p>"},{"location":"reference.html#impellerpy.TextAlignment.CENTER","title":"<code>CENTER = 2</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Center text horizontally.</p>"},{"location":"reference.html#impellerpy.TextAlignment.END","title":"<code>END = 5</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Align text to the end of the line (depends on text direction).</p>"},{"location":"reference.html#impellerpy.TextAlignment.JUSTIFY","title":"<code>JUSTIFY = 3</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Stretch text to fill the width.</p>"},{"location":"reference.html#impellerpy.TextAlignment.LEFT","title":"<code>LEFT = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Align text to the left.</p>"},{"location":"reference.html#impellerpy.TextAlignment.RIGHT","title":"<code>RIGHT = 1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Align text to the right.</p>"},{"location":"reference.html#impellerpy.TextAlignment.START","title":"<code>START = 4</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Align text to the start of the line (depends on text direction).</p>"},{"location":"reference.html#impellerpy.TextDirection","title":"<code>TextDirection</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Specifies the direction of text flow.</p>"},{"location":"reference.html#impellerpy.TextDirection.LTR","title":"<code>LTR = 1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Left-to-right text direction.</p>"},{"location":"reference.html#impellerpy.TextDirection.RTL","title":"<code>RTL = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Right-to-left text direction.</p>"},{"location":"reference.html#impellerpy.Texture","title":"<code>Texture</code>","text":"<p>               Bases: <code>Texture_</code></p>"},{"location":"reference.html#impellerpy.TextureDescriptor","title":"<code>TextureDescriptor</code>","text":"<p>               Bases: <code>TextureDescriptor_</code></p>"},{"location":"reference.html#impellerpy.TextureDescriptor.mip_count","title":"<code>mip_count = mip_count</code>  <code>instance-attribute</code>","text":""},{"location":"reference.html#impellerpy.TextureDescriptor.pixel_format","title":"<code>pixel_format = pixel_format</code>  <code>instance-attribute</code>","text":""},{"location":"reference.html#impellerpy.TextureDescriptor.size","title":"<code>size = texture_size</code>  <code>instance-attribute</code>","text":""},{"location":"reference.html#impellerpy.TextureDescriptor.__init__","title":"<code>__init__(pixel_format, texture_size, mip_count=1)</code>","text":""},{"location":"reference.html#impellerpy.TextureDescriptor_","title":"<code>TextureDescriptor_</code>","text":"<p>Describes the properties of a texture.</p> <p>Attributes:</p> Name Type Description <code>pixel_format</code> <code>PixelFormat</code> <p>The format of pixels in the texture.</p> <code>size</code> <code>ISize_</code> <p>The dimensions of the texture in pixels.</p> <code>mip_count</code> <code>int</code> <p>The number of mipmap levels in the texture.</p>"},{"location":"reference.html#impellerpy.TextureDescriptor_.mip_count","title":"<code>mip_count</code>  <code>instance-attribute</code>","text":""},{"location":"reference.html#impellerpy.TextureDescriptor_.pixel_format","title":"<code>pixel_format</code>  <code>instance-attribute</code>","text":""},{"location":"reference.html#impellerpy.TextureDescriptor_.size","title":"<code>size</code>  <code>instance-attribute</code>","text":""},{"location":"reference.html#impellerpy.TextureDescriptor_.__init__","title":"<code>__init__()</code>","text":"<p>Initialize a texture descriptor with default values.</p>"},{"location":"reference.html#impellerpy.TextureSampling","title":"<code>TextureSampling</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Determines how textures are sampled when drawn.</p>"},{"location":"reference.html#impellerpy.TextureSampling.LINEAR","title":"<code>LINEAR = 1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Interpolate between neighboring pixels.</p>"},{"location":"reference.html#impellerpy.TextureSampling.NEAREST_NEIGHBOR","title":"<code>NEAREST_NEIGHBOR = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use the nearest pixel value.</p>"},{"location":"reference.html#impellerpy.Texture_","title":"<code>Texture_</code>","text":"<p>A reference to a texture whose data is resident on the GPU.</p> <p>Textures can be referenced in draw calls and paints. Creating textures is extremely expensive and should be done on background threads when possible.</p>"},{"location":"reference.html#impellerpy.Texture_.with_contents","title":"<code>with_contents(context, desc, data)</code>  <code>staticmethod</code>","text":"<p>Create a texture with decompressed bytes.</p> <p>Note: Do not supply compressed image data directly (PNG, JPEG, etc.). This function only works with tightly packed decompressed data.</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>Context_</code> <p>The graphics context.</p> required <code>desc</code> <code>TextureDescriptor_</code> <p>The texture descriptor.</p> required <code>data</code> <code>bytes</code> <p>The raw pixel data.</p> required <p>Returns:</p> Type Description <code>Texture_</code> <p>A new texture.</p>"},{"location":"reference.html#impellerpy.TileMode","title":"<code>TileMode</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Determines how textures and gradients behave outside their bounds.</p>"},{"location":"reference.html#impellerpy.TileMode.CLAMP","title":"<code>CLAMP = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use the color at the nearest edge.</p>"},{"location":"reference.html#impellerpy.TileMode.DECAL","title":"<code>DECAL = 3</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use transparent black outside the bounds.</p>"},{"location":"reference.html#impellerpy.TileMode.MIRROR","title":"<code>MIRROR = 2</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Repeat the texture or gradient, mirroring on each repetition.</p>"},{"location":"reference.html#impellerpy.TileMode.REPEAT","title":"<code>REPEAT = 1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Repeat the texture or gradient.</p>"},{"location":"reference.html#impellerpy.TypographyContext","title":"<code>TypographyContext</code>","text":"<p>               Bases: <code>TypographyContext_</code></p>"},{"location":"reference.html#impellerpy.TypographyContext_","title":"<code>TypographyContext_</code>","text":"<p>A context for text layout and rendering.</p> <p>Typography contexts allow for the layout and rendering of text. These are typically expensive to create and applications will only ever need to create a single one during their lifetimes.</p> <p>Unlike graphics contexts, typography contexts are not thread-safe. These must be created, used, and collected on a single thread.</p>"},{"location":"reference.html#impellerpy.TypographyContext_.__init__","title":"<code>__init__()</code>","text":"<p>Initialize a new typography context.</p>"},{"location":"reference.html#impellerpy.Window","title":"<code>Window</code>","text":"<p>               Bases: <code>Window_</code></p>"},{"location":"reference.html#impellerpy.Window.__init__","title":"<code>__init__()</code>","text":""},{"location":"reference.html#impellerpy.Window_","title":"<code>Window_</code>","text":"<p>A window for rendering content.</p> <p>Provides a platform-specific window and handles for creating render surfaces.</p>"},{"location":"reference.html#impellerpy.Window_.__init__","title":"<code>__init__()</code>","text":"<p>Initialize a new window with default size (800x600).</p>"},{"location":"reference.html#impellerpy.Window_.create_render_surface","title":"<code>create_render_surface(context)</code>","text":"<p>Create a render surface for the window.</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>Context_</code> <p>The graphics context to use.</p> required <p>Returns:</p> Type Description <code>Surface_</code> <p>A new surface for rendering to the window.</p>"},{"location":"reference.html#impellerpy.Window_.poll_events","title":"<code>poll_events()</code>","text":"<p>Process all pending window events.</p>"},{"location":"reference.html#impellerpy.Window_.should_close","title":"<code>should_close()</code>","text":"<p>Check if the window should close.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the window should close, False otherwise.</p>"},{"location":"reference.html#impellerpy.get_version","title":"<code>get_version()</code>","text":"<p>Get the version of Impeller standalone API.</p> <p>This is the API version that will be accepted for validity checks when provided to the context creation methods. The current version of the API is denoted by the <code>IMPELLER_VERSION</code> macro.</p> <p>Returns:</p> Type Description <code>int</code> <p>The version of the standalone API.</p>"},{"location":"usage.html","title":"Usage","text":"uvpip <p>Add to your UV dependencies.</p> <pre><code>uv add impellerpy\n</code></pre> <p>Add to your pip dependencies.</p> <pre><code>pip install impellerpy\n</code></pre>"}]}